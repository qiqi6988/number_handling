Good ones for gcc and ioc are the same with the given output

Bad ones for gcc are the same with the given output(infinite running and no output)

Bad ones for ioc are trapped with the errors:

Analysis1:
Bad1:./countlines_ioc_notrap long.java 527
countlines.c:88:27: runtime error: value lost in conversion of '527' from 'int' (int) to 'char' (char)
countlines.c:273:42: runtime error: value lost in conversion of '-25' from 'int' (int) to 'unsigned int' (unsigned int)
116-53-6526 0


code:max_line_length = (char) atoi ( argv[2] ); 
argv[2] is input by the user, and it is "527". when it is converted to char, it becomes 25. Thus, the max_line_length is 25, rather than 527. Thus, the limitation of the length of a line gets more strict than what we want, and turns to be wrong. It will execute " remaining_chars = ( unsigned int ) (max_line_length - place);"



Bad2:./countlines_ioc 2.java 90   
Bad3:./countlines_ioc hamlet.txt 68
The max_line_length that input by the user is relatively small than the lines' length in the input file. Thus it will execute " remaining_chars = ( unsigned int ) (max_line_length - place);".



